#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Dec 26 17:40:46 2023

@author: yanbin
"""

import numpy as np
import matplotlib.pyplot as plt

def separate_frames_to_numpy(file_path):
    with open(file_path, 'r') as file:
        file_lines = file.readlines()

    frames = []
    current_frame = []

    for line in file_lines:
        if line.startswith("generated by VMD"):
            if current_frame:
                # Convert current frame to numpy array and add to frames list
                frames.append(np.array(current_frame))
                current_frame = []
        else:
            # Extract coordinates from the line and append to current frame
            parts = line.split()
            if len(parts) >= 6:
                # Assuming coordinates are in columns 4, 5, and 6
                coordinates = [float(parts[3]), float(parts[4]), float(parts[5])]
                current_frame.append(coordinates)

    # Add the last frame
    if current_frame:
        frames.append(np.array(current_frame))

    return frames

# Usage example:
file_path = 'ala_noh.gro'  # Path to the uploaded file
tot_frames = separate_frames_to_numpy(file_path)

frame_filter = np.loadtxt('COLVAR')
indices = frame_filter[:,0].astype(int)
frames = [tot_frames[index] for index in indices] 

####################################RMSD
def calculate_rmsd(coords1, coords2, weights):
    # Ensure the number of atoms in both conformations are the same
    if coords1.shape != coords2.shape:
        raise ValueError("The number of atoms in both conformations must be the same.")
    # Ensure the weights array is compatible
    weights = np.array(weights)  # Convert weights to a NumPy array if not already
    if weights.shape[0] != coords1.shape[0]:
        raise ValueError("The length of the weights array must match the number of atoms.")
    # Reshape weights to be compatible for element-wise multiplication
    weights_reshaped = weights[:, np.newaxis]
    # Calculate the squared differences
    diff_squared = np.square(coords1 - coords2) * weights_reshaped
    # Calculate RMSD
    rmsd = np.sqrt(np.mean(diff_squared))
    return rmsd

def rmsd_Ker(s,weights,rmsd):
    pre = -0.5 / s
    #prob = calcProb(points,0.1,1,weights)
    rmsd_ker = np.exp(rmsd**2 * pre)
    rmsd_prob = np.sum(rmsd_ker,axis=1)
    # print(rmsd_ker.shape)
    prob_unbias = (rmsd_prob*weights)/np.sum(weights)
    prob_unbias = prob_unbias/np.sum(prob_unbias)
    #prob = np.sum(rmsd_ker,axis=1) # this shall be true prob
    prefactors = weights/np.sqrt(prob_unbias)

    pre_matrix = np.tile(prefactors.reshape(1, -1), (prefactors.shape[0], 1))
    results = rmsd_ker*pre_matrix
    norm_f = np.sum(results, axis=1, keepdims=True)
    #print(norm_f.shape)
    normalized_results = results / norm_f  # Normalize the results
    Ker = normalized_results  
    D = norm_f.squeeze()
    D2 = np.sqrt(D*prefactors)
    return Ker,D2

def symEig(M,D,ndiml):
    Ms = D.reshape(-1,1)*M/D.reshape(1,-1)
    v,w = np.linalg.eigh(Ms)
    v_out = v[-ndiml:]
    w_out = w[:,-ndiml:]
    w_r = w_out/D.reshape(-1,1)
    w_l = w_out*D.reshape(-1,1)
    eps = 1e-10
    sum_w   = np.sum(weights, axis=-1, keepdims=True)
    denom   = np.sum(weights[..., :, None] * (w_r ** 2), axis=-2, keepdims=True)
    scale   = np.sqrt(sum_w[..., None] / (denom + eps))
    w_r_normalized = w_r* scale
    w_r_normalized = w_r_normalized / np.linalg.norm(w_r_normalized, axis=0)
    w_l = w_out * D.reshape(-1, 1)
    # Save directly as NumPy arrays
    np.savetxt('eig-vec-r', w_r_normalized)
    np.savetxt('eig-vec-l', w_l)
    return v_out,w_r,w_l
#####################################################
# 0    1   2    3    4 5 6 7 8  9  10 11  12  13  14 15 16 17 18  19   20   21     
# HH31 CH3 HH32 HH33 C O N H CA HA CB HB1 HB2 HB3 C  O  N  H  CH3 HH31 HH32 HH33
weights_atoms = np.ones(22)
indices_1 = [0, 2, 3, 9, 11, 12, 13, 19, 20, 21,17,7]
weights_atoms[indices_1] *= 0.1
indices_2 = [4, 6, 8, 14, 16, 5,15]
weights_atoms[indices_2] *= 10
indices_3 = [1, 10, 18]
weights_atoms[indices_3] *= 1
print(weights_atoms)

weights_atoms = weights_atoms/np.sum(weights_atoms)
#####################################################
N = len(frames)
rmsd_value = np.zeros((N, N))
for i in range(N):
    for j in range(i, N):  # Start from 'i' to avoid recomputing
        rmsd_value[i, j] = calculate_rmsd(frames[i][:22], frames[j][:22],weights_atoms)
        rmsd_value[j, i] = rmsd_value[i, j]  # Exploit symmetry

#plt.plot(rmsd_value)

weights = np.loadtxt("weight-out-only")
weights = weights*(N/np.sum(weights))

s = 0.001 # sigma
rmsd_results = rmsd_Ker(s,weights,rmsd_value)
Kernel = rmsd_results[0]
D =  rmsd_results[1]

row_m = np.sum(Kernel,axis=0)
col_m = np.sum(Kernel,axis=1)
v,w_r,w_l = symEig(Kernel,D,5)
v_out = (1.0-v.T)/s
np.savetxt('v_out.dat', v_out)
print(v_out)
np.savetxt('row_m_np.dat', row_m)
